{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/sd-random.js","index.js"],"names":["require","r","e","n","t","o","i","f","c","u","a","Error","code","p","exports","call","length","1","module","b","NaN","Math","random","beta","log","alpha","minimum","pow","k","m","mult","sqrt","d","p1","p2","mean","std","exp","Normal","sum","Bernoulli","floor","lambda","_u","_x","_u2","E","_u3","ainv","bbb","ccc","u1","u2","v","x","z","cos","PI","_sdRandom","Object","keys","forEach","key","defineProperty","enumerable","get"],"mappings":"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","file":"sd-random.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","export const menuList = [\"Uniform(0.0,1.0)\", \"Exponential(1.0)\",\n                         \"Normal(0.0,1.0)\", \"Pareto(1.0,1.0)\",\n                         \"Weibull(1.0,1.0)\", \"Triangular(0.0,1.0,0.5)\",\n                         \"Trapezoidal(0.0,1.0,0.25,0.75)\",\n                         \"LogNormal(0.0,1.0)\", \"Gamma(1.0,1.0)\",\n                         \"Loglogistic(1.0,0.5)\",\"Erlang(4,0.5)\",\n                         \"Bernoulli(0.5)\",\"Binomial(2,0.5)\",\n                         \"Geometric(0.5)\", \"Poisson(2.0)\"];\n\nexport const functionNameList = [\"Uniform\", \"Exponential\",\n                                 \"Normal\", \"Pareto\",\n                                 \"Weibull\", \"Triangular\",\n                                 \"Trapezoidal\",\n                                 \"LogNormal\", \"Gamma\",\n                                 \"Loglogistic\",\"Erlang\",\n                                 \"Bernoulli\",\"Binomial\",\n                                 \"Geometric\", \"Poisson\"];\n\n\nexport const random = Math.random;\n\n/**\n * Uniform distribution implementation.\n * More details at A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 452\n * @param a lower bound\n * @param b upper bound, b >= a\n * @returns Uniform distributed random value\n */\nexport function Uniform(a, b) {\n    if (a == null) a = 0.0;\n    if (b == null) b = 1.0;\n\tif (b < a) return NaN;\n    return a + (b - a)*Math.random();\n}\n\n/**\n * Exponential distribution mplementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 452 \n * @param beta shape parameter, beta > 0,  lambda = 1/beta. For exponential distribution beta is equal to the mean.\n * @returns Exponentially distributed random value\n */\nexport function Exponential(beta) {\n\tif (beta==null) beta == 1;\n\tif (beta<=0) return NaN;\t\n    return -beta * Math.log(Math.random());\n}\n\n/**\n * Normal distribution implementation based on Box and Muller (1958) algorithm\n * Please note that in order to not to store state in this library we use only odd values\n * For discussion see A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 457\n * @param mean mean value\n * @param std standard deviation, std>=0\n * @returns Normally distributed random value\n */\nexport function Normal(mean, std) {\n    if (mean == null) mean = 0.0;\n    if (std == null) std = 1.0;\n    if (std < 0) return NaN;\n\n    let n = Math.sqrt(-2.0 * Math.log(Math.random())) * Math.cos(2.0 * Math.PI * Math.random());\n    return n * std + mean;\n}\n/**\n * Pareto distribution implementation based on \n * https://en.wikipedia.org/wiki/Pareto_distribution#Random_sample_generation\n * \n * @param alpha shape parameter, alpha > 0\n * @param minimum scale parameter, minimum > 0\n * @returns\n */\nexport function Pareto(alpha, minimum) {\n\tif (alpha == null) alpha = 1.0;\n\tif (minimum == null) minimum = 1.0;\n\tif (alpha <= 0 || minimum <= 0) return NaN;\n    return minimum / Math.pow(Math.random(), 1.0 / alpha);\n}\n\n\n/**\n * Log-logistic distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 460\n * @param alpha shape parameter, alpha > 0\n * @param beta scale parameter, beta > 0\n * @returns Log-logistic distributed random value\n */\nexport function Loglogistic(alpha, beta) {\n\tif (alpha == null) alpha = 1.0;\n\tif (beta == null) beta = 1.0;\n\tif (beta <= 0 || alpha <= 0) return NaN;\n\tvar u = Math.random();\n\treturn beta * Math.pow(u/(1-u), 1/alpha);\t\n}\n\n\n/**\n * Weibull distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 456\n * @param alpha shape parameter, alpha > 0\n * @param beta scale parameter, beta > 0\n * @returns Weibull distributed random value\n */\nexport function Weibull(alpha, beta) {\n\tif (alpha == null) alpha = 1.0;\n\tif (beta == null) beta = 1.0;\n\tif (beta <= 0 || alpha <= 0) return NaN;\t\n    return beta * Math.pow(-Math.log(1.0 - Math.random()), 1.0 / alpha);\n}\n\n\n/**\n * Erlang distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 453\n * @param k shape parameter, k = 1,2,3,...\n * @param beta scale parameter, beta > 0, beta = 1/lambda. For Erlang distribution beta is equal to the mean value.\n * @returns Erlang distributed random value\n */\nexport function Erlang(k, beta) {\n\tif (k == null) k = 1;\n\tif (beta == null) beta = 1.0;\n\tvar m = k | 0;\n\tif (beta <= 0 || m <= 0) return NaN;\n\tvar mult = 1.0;\n\tfor (var i=0;i<m;i++) {\n\t\tmult *= Math.random();\n\t}\n    return -beta/m*Math.log(mult);\n}\n\n\n/**\n * Triangular distribution implementation\n * @param a left side\n * @param b right side, b >= a\n * @param m triangle peak (mode), a <= m <= b\n * @returns Triangular distributed random value\n */\nexport function Triangular(a, b, m) {\n    if (a == null) a = 0.0;\n    if (b == null) b = 1.0;\n    if (m == null) m = 0.5;\n    if (a>b || m < a || m > b) return NaN;\n\tif (a==b) return a;\n    var c = (m - a) / (b - a);\n    var p = Math.random();\n    if (p <= c) {\n        return a + Math.sqrt(p * (b - a) * (m - a));\n    } else {\n        return b - Math.sqrt((1 - p) * (b - a) * (b - m));\n    }\n}\n\n\n/**\n * Trapezoidal distribution implementation\n * @param a left side\n * @param b right side, b >= a\n * @param c left trapezoid peak (mode)\n * @param d right trapezoid peak (mode), a <= c <= d <= b\n * @returns Trapezoidal distributed random value\n */\nexport function Trapezoidal(a, b, c, d) {\n    if (a == null) a = 0.0;\n    if (b == null) b = 1.0;\n    if (c == null) c = 0.25;\n    if (d == null) d = 0.75;\n    if (a > b || c < a || c > d || d > b) return NaN;\n\tif (a==b) return a;\n    var p1 = (c - a) / ( (b - a)+(d - c));\n    var p2 = (b - d) / ( (b - a)+(d - c));\n    var p = Math.random();\n    \n    if (p <= p1) {\n        return a + Math.sqrt(p * ((b - a)+(d - c)) * (c - a) );\n    } else if (p > 1-p2) {\n        return b - Math.sqrt((1 - p) * ((b - a)+(d - c)) * (b - d));\n    } else {\n    \treturn c + (d-c)*(p-p1)/(1.0 - p1 - p2);\n    }\n}\n\n/**\n * Lognormal distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 458\n * @param mean mean value\n * @param std standard deviation\n * @returns Lognormally distributed random value\n */\nexport function LogNormal(mean, std) {\n    if (mean == null) mean = 0.0;\n    if (std == null) std = 1.0;\n    if (std < 0) return NaN;\n    return Math.exp(Normal(mean, std))\n}\n\n\n\n/**\n * Bernoulli distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 464\n * @param p probability of 1\n * @returns Bernoulli distributed random value (zero or one)\n */\nexport function Bernoulli(p) {\n\tif (p==null) p = 0.5;\n\tif (p<0.0 | p > 1.0) return NaN;\n    if (Math.random()<=p)\n    \treturn 1;\n    else \n    \treturn 0;\n}\n\n\n/**\n * Binomial distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 469\n * @param n number of trials\n * @param p success probability in each trial\n * @returns Binomial distributed random value (0,1,...,n)\n */\nexport function Binomial(n,p) {\n\tif (n==null) n = 1;\n\tif (p==null) p = 0.5;\t\n\tvar t = n | 0;\n\tif ( p < 0.0 | p > 1.0 | t <= 0) return NaN;\n\tvar sum = 0;\n\tfor (var i=0;i<t;i++) {\n\t\tsum += Bernoulli(p);\n\t}\n    return sum;\n}\n\n/**\n * Geometric distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 469\n * @param p success probability \n * @returns Geometric distributed random value \n */\nexport function Geometric(p) {\n\tif (p==null) p = 0.5;\t\n\tif ( p <= 0.0 | p >= 1.0 ) return NaN;\t\n    return Math.floor(Math.log(Math.random())/Math.log(1-p) ) | 0;\n}\n\n/**\n * Poisson distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 470\n * @param lambda mean value \n * @returns Poisson distributed random value \n */\nexport function Poisson(lambda) {\n\tif (lambda==null) lambda = 1.0;\t\n\tif ( lambda <= 0.0 ) return NaN;\t\n\tvar a = Math.exp(-lambda);\n\tvar b = 1.0;\n\tvar i = 0;\t\n\twhile (true) {\n\t\tvar u = Math.random();\n\t\tb *= u;\n\t\tif (b < a) return i;\n\t\ti += 1;\n\t}\n}\n\n/**\n * Gamma distribution implementation.\n * This code has been copied from\n * https://github.com/btelles/simjs-updated/\n * simjs-updated is licensed under MIT Open Source License termns \n * @param alpha shape parameter\n * @param beta rate parameter \n * @returns Gamma distributed random value.\n */\nexport function Gamma(alpha, beta) {\n\tif (alpha == null) alpha = 1.0;\n\tif (beta == null) beta = 1.0;\n    if (alpha > 1.0) {\n        let ainv = Math.sqrt(2.0 * alpha - 1.0),\n            bbb = alpha - Math.log(4.0),\n            ccc = alpha + ainv;\n\n        while (true) {  // eslint-disable-line no-constant-condition\n            let u1 = random();\n\n            if ((u1 < 1e-7) || (u > 0.9999999)) {\n                continue;\n            }\n            let u2 = 1.0 - random(),\n                v = Math.log(u1 / (1.0 - u1)) / ainv,\n                x = alpha * Math.exp(v),\n                z = u1 * u1 * u2,\n                r = bbb + ccc * v - x;\n            if ((r + Math.log(4.5) - 3.5 * z >= 0.0) || (r >= Math.log(z))) {\n                return x * beta;\n            }\n        }\n    } else if (alpha == 1.0) {\n        let u = random();\n        while (u <= 1e-7) {\n            u = random();\n        }\n        return -Math.log(u) * beta;\n    } else {\n        let x;\n        while (true) {\n            let u = random(),\n                b = (Math.E + alpha) / Math.E,\n                p = b * u;\n            if (p <= 1.0) {\n                x = Math.pow(p, 1.0 / alpha);\n            } else {\n                x = -Math.log((b - p) / alpha);\n            }\n            const u1 = random();\n\n            if (p > 1.0) {\n                if (u1 <= Math.pow(x, (alpha - 1.0))) {\n                    break;\n                }\n            } else if (u1 <= Math.exp(-x)) {\n                break;\n            }\n        }\n        return x * beta;\n    }\n}\n","export * from './src/sd-random';\n"]}