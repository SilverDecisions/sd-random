{"version":3,"sources":["node_modules/browser-pack/_prelude.js","sd-random.js","src/sd-random.js","index.js"],"names":["require","e","t","n","r","s","o","u","a","i","f","Error","code","l","exports","call","length","1","module","Uniform","b","NaN","Math","random","Exponential","beta","log","Normal","mean","std","sqrt","cos","PI","Pareto","alpha","minimum","pow","Loglogistic","Weibull","Erlang","k","m","mult","Triangular","c","p","Trapezoidal","d","p1","p2","LogNormal","exp","Bernoulli","Binomial","sum","Geometric","floor","Poisson","lambda","Gamma","_u","_x","_u2","E","_u3","ainv","bbb","ccc","u1","u2","v","x","z","Object","defineProperty","value","menuList","functionNameList","sd-random","_sdRandom","keys","forEach","key","enumerable","get","./src/sd-random"],"mappings":"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","file":"sd-random.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Uniform = Uniform;\nexports.Exponential = Exponential;\nexports.Normal = Normal;\nexports.Pareto = Pareto;\nexports.Loglogistic = Loglogistic;\nexports.Weibull = Weibull;\nexports.Erlang = Erlang;\nexports.Triangular = Triangular;\nexports.Trapezoidal = Trapezoidal;\nexports.LogNormal = LogNormal;\nexports.Bernoulli = Bernoulli;\nexports.Binomial = Binomial;\nexports.Geometric = Geometric;\nexports.Poisson = Poisson;\nexports.Gamma = Gamma;\nvar menuList = exports.menuList = [\"Uniform(0.0,1.0)\", \"Exponential(1.0)\", \"Normal(0.0,1.0)\", \"Pareto(1.0,1.0)\", \"Weibull(1.0,1.0)\", \"Triangular(0.0,1.0,0.5)\", \"Trapezoidal(0.0,1.0,0.25,0.75)\", \"LogNormal(0.0,1.0)\", \"Gamma(1.0,1.0)\", \"Loglogistic(1.0,0.5)\", \"Erlang(4,0.5)\", \"Bernoulli(0.5)\", \"Binomial(2,0.5)\", \"Geometric(0.5)\", \"Poisson(2.0)\"];\n\nvar functionNameList = exports.functionNameList = [\"Uniform\", \"Exponential\", \"Normal\", \"Pareto\", \"Weibull\", \"Triangular\", \"Trapezoidal\", \"LogNormal\", \"Gamma\", \"Loglogistic\", \"Erlang\", \"Bernoulli\", \"Binomial\", \"Geometric\", \"Poisson\"];\n\nvar random = exports.random = Math.random;\n\n/**\n * Uniform distribution implementation.\n * More details at A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 452\n * @param a lower bound\n * @param b upper bound, b >= a\n * @returns Uniform distributed random value\n */\nfunction Uniform(a, b) {\n    if (a == null) a = 0.0;\n    if (b == null) b = 1.0;\n    if (b < a) return NaN;\n    return a + (b - a) * Math.random();\n}\n\n/**\n * Exponential distribution mplementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 452 \n * @param beta shape parameter, beta > 0,  lambda = 1/beta. For exponential distribution beta is equal to the mean.\n * @returns Exponentially distributed random value\n */\nfunction Exponential(beta) {\n    if (beta == null) beta == 1;\n    if (beta <= 0) return NaN;\n    return -beta * Math.log(Math.random());\n}\n\n/**\n * Normal distribution implementation based on Box and Muller (1958) algorithm\n * Please note that in order to not to store state in this library we use only odd values\n * For discussion see A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 457\n * @param mean mean value\n * @param std standard deviation, std>=0\n * @returns Normally distributed random value\n */\nfunction Normal(mean, std) {\n    if (mean == null) mean = 0.0;\n    if (std == null) std = 1.0;\n    if (std < 0) return NaN;\n\n    var n = Math.sqrt(-2.0 * Math.log(Math.random())) * Math.cos(2.0 * Math.PI * Math.random());\n    return n * std + mean;\n}\n/**\n * Pareto distribution implementation based on \n * https://en.wikipedia.org/wiki/Pareto_distribution#Random_sample_generation\n * \n * @param alpha shape parameter, alpha > 0\n * @param minimum scale parameter, minimum > 0\n * @returns\n */\nfunction Pareto(alpha, minimum) {\n    if (alpha == null) alpha = 1.0;\n    if (minimum == null) minimum = 1.0;\n    if (alpha <= 0 || minimum <= 0) return NaN;\n    return minimum / Math.pow(Math.random(), 1.0 / alpha);\n}\n\n/**\n * Log-logistic distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 460\n * @param alpha shape parameter, alpha > 0\n * @param beta scale parameter, beta > 0\n * @returns Log-logistic distributed random value\n */\nfunction Loglogistic(alpha, beta) {\n    if (alpha == null) alpha = 1.0;\n    if (beta == null) beta = 1.0;\n    if (beta <= 0 || alpha <= 0) return NaN;\n    var u = Math.random();\n    return beta * Math.pow(u / (1 - u), 1 / alpha);\n}\n\n/**\n * Weibull distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 456\n * @param alpha shape parameter, alpha > 0\n * @param beta scale parameter, beta > 0\n * @returns Weibull distributed random value\n */\nfunction Weibull(alpha, beta) {\n    if (alpha == null) alpha = 1.0;\n    if (beta == null) beta = 1.0;\n    if (beta <= 0 || alpha <= 0) return NaN;\n    return beta * Math.pow(-Math.log(1.0 - Math.random()), 1.0 / alpha);\n}\n\n/**\n * Erlang distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 453\n * @param k shape parameter, k = 1,2,3,...\n * @param beta scale parameter, beta > 0, beta = 1/lambda. For Erlang distribution beta is equal to the mean value.\n * @returns Erlang distributed random value\n */\nfunction Erlang(k, beta) {\n    if (k == null) k = 1;\n    if (beta == null) beta = 1.0;\n    var m = k | 0;\n    if (beta <= 0 || m <= 0) return NaN;\n    var mult = 1.0;\n    for (var i = 0; i < m; i++) {\n        mult *= Math.random();\n    }\n    return -beta / m * Math.log(mult);\n}\n\n/**\n * Triangular distribution implementation\n * @param a left side\n * @param b right side, b >= a\n * @param m triangle peak (mode), a <= m <= b\n * @returns Triangular distributed random value\n */\nfunction Triangular(a, b, m) {\n    if (a == null) a = 0.0;\n    if (b == null) b = 1.0;\n    if (m == null) m = 0.5;\n    if (a > b || m < a || m > b) return NaN;\n    if (a == b) return a;\n    var c = (m - a) / (b - a);\n    var p = Math.random();\n    if (p <= c) {\n        return a + Math.sqrt(p * (b - a) * (m - a));\n    } else {\n        return b - Math.sqrt((1 - p) * (b - a) * (b - m));\n    }\n}\n\n/**\n * Trapezoidal distribution implementation\n * @param a left side\n * @param b right side, b >= a\n * @param c left trapezoid peak (mode)\n * @param d right trapezoid peak (mode), a <= c <= d <= b\n * @returns Trapezoidal distributed random value\n */\nfunction Trapezoidal(a, b, c, d) {\n    if (a == null) a = 0.0;\n    if (b == null) b = 1.0;\n    if (c == null) c = 0.25;\n    if (d == null) d = 0.75;\n    if (a > b || c < a || c > d || d > b) return NaN;\n    if (a == b) return a;\n    var p1 = (c - a) / (b - a + (d - c));\n    var p2 = (b - d) / (b - a + (d - c));\n    var p = Math.random();\n\n    if (p <= p1) {\n        return a + Math.sqrt(p * (b - a + (d - c)) * (c - a));\n    } else if (p > 1 - p2) {\n        return b - Math.sqrt((1 - p) * (b - a + (d - c)) * (b - d));\n    } else {\n        return c + (d - c) * (p - p1) / (1.0 - p1 - p2);\n    }\n}\n\n/**\n * Lognormal distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 458\n * @param mean mean value\n * @param std standard deviation\n * @returns Lognormally distributed random value\n */\nfunction LogNormal(mean, std) {\n    if (mean == null) mean = 0.0;\n    if (std == null) std = 1.0;\n    if (std < 0) return NaN;\n    return Math.exp(Normal(mean, std));\n}\n\n/**\n * Bernoulli distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 464\n * @param p probability of 1\n * @returns Bernoulli distributed random value (zero or one)\n */\nfunction Bernoulli(p) {\n    if (p == null) p = 0.5;\n    if (p < 0.0 | p > 1.0) return NaN;\n    if (Math.random() <= p) return 1;else return 0;\n}\n\n/**\n * Binomial distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 469\n * @param n number of trials\n * @param p success probability in each trial\n * @returns Binomial distributed random value (0,1,...,n)\n */\nfunction Binomial(n, p) {\n    if (n == null) n = 1;\n    if (p == null) p = 0.5;\n    var t = n | 0;\n    if (p < 0.0 | p > 1.0 | t <= 0) return NaN;\n    var sum = 0;\n    for (var i = 0; i < t; i++) {\n        sum += Bernoulli(p);\n    }\n    return sum;\n}\n\n/**\n * Geometric distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 469\n * @param p success probability \n * @returns Geometric distributed random value \n */\nfunction Geometric(p) {\n    if (p == null) p = 0.5;\n    if (p <= 0.0 | p >= 1.0) return NaN;\n    return Math.floor(Math.log(Math.random()) / Math.log(1 - p)) | 0;\n}\n\n/**\n * Poisson distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 470\n * @param lambda mean value \n * @returns Poisson distributed random value \n */\nfunction Poisson(lambda) {\n    if (lambda == null) lambda = 1.0;\n    if (lambda <= 0.0) return NaN;\n    var a = Math.exp(-lambda);\n    var b = 1.0;\n    var i = 0;\n    while (true) {\n        var u = Math.random();\n        b *= u;\n        if (b < a) return i;\n        i += 1;\n    }\n}\n\n/**\n * Gamma distribution implementation.\n * This code has been copied from\n * https://github.com/btelles/simjs-updated/\n * simjs-updated is licensed under MIT Open Source License termns \n * @param alpha shape parameter\n * @param beta rate parameter \n * @returns Gamma distributed random value.\n */\nfunction Gamma(alpha, beta) {\n    if (alpha == null) alpha = 1.0;\n    if (beta == null) beta = 1.0;\n    if (alpha > 1.0) {\n        var ainv = Math.sqrt(2.0 * alpha - 1.0),\n            bbb = alpha - Math.log(4.0),\n            ccc = alpha + ainv;\n\n        while (true) {\n            // eslint-disable-line no-constant-condition\n            var u1 = random();\n\n            if (u1 < 1e-7 || u > 0.9999999) {\n                continue;\n            }\n            var u2 = 1.0 - random(),\n                v = Math.log(u1 / (1.0 - u1)) / ainv,\n                x = alpha * Math.exp(v),\n                z = u1 * u1 * u2,\n                r = bbb + ccc * v - x;\n            if (r + Math.log(4.5) - 3.5 * z >= 0.0 || r >= Math.log(z)) {\n                return x * beta;\n            }\n        }\n    } else if (alpha == 1.0) {\n        var _u = random();\n        while (_u <= 1e-7) {\n            _u = random();\n        }\n        return -Math.log(_u) * beta;\n    } else {\n        var _x = void 0;\n        while (true) {\n            var _u2 = random(),\n                b = (Math.E + alpha) / Math.E,\n                p = b * _u2;\n            if (p <= 1.0) {\n                _x = Math.pow(p, 1.0 / alpha);\n            } else {\n                _x = -Math.log((b - p) / alpha);\n            }\n            var _u3 = random();\n\n            if (p > 1.0) {\n                if (_u3 <= Math.pow(_x, alpha - 1.0)) {\n                    break;\n                }\n            } else if (_u3 <= Math.exp(-_x)) {\n                break;\n            }\n        }\n        return _x * beta;\n    }\n}\n\n},{}],\"sd-random\":[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _sdRandom = require('./src/sd-random');\n\nObject.keys(_sdRandom).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _sdRandom[key];\n    }\n  });\n});\n\n},{\"./src/sd-random\":1}]},{},[])\n\n","export const menuList = [\"Uniform(0.0,1.0)\", \"Exponential(1.0)\",\n                         \"Normal(0.0,1.0)\", \"Pareto(1.0,1.0)\",\n                         \"Weibull(1.0,1.0)\", \"Triangular(0.0,1.0,0.5)\",\n                         \"Trapezoidal(0.0,1.0,0.25,0.75)\",\n                         \"LogNormal(0.0,1.0)\", \"Gamma(1.0,1.0)\",\n                         \"Loglogistic(1.0,0.5)\",\"Erlang(4,0.5)\",\n                         \"Bernoulli(0.5)\",\"Binomial(2,0.5)\",\n                         \"Geometric(0.5)\", \"Poisson(2.0)\"];\n\nexport const functionNameList = [\"Uniform\", \"Exponential\",\n                                 \"Normal\", \"Pareto\",\n                                 \"Weibull\", \"Triangular\",\n                                 \"Trapezoidal\",\n                                 \"LogNormal\", \"Gamma\",\n                                 \"Loglogistic\",\"Erlang\",\n                                 \"Bernoulli\",\"Binomial\",\n                                 \"Geometric\", \"Poisson\"];\n\n\nexport const random = Math.random;\n\n/**\n * Uniform distribution implementation.\n * More details at A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 452\n * @param a lower bound\n * @param b upper bound, b >= a\n * @returns Uniform distributed random value\n */\nexport function Uniform(a, b) {\n    if (a == null) a = 0.0;\n    if (b == null) b = 1.0;\n\tif (b < a) return NaN;\n    return a + (b - a)*Math.random();\n}\n\n/**\n * Exponential distribution mplementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 452 \n * @param beta shape parameter, beta > 0,  lambda = 1/beta. For exponential distribution beta is equal to the mean.\n * @returns Exponentially distributed random value\n */\nexport function Exponential(beta) {\n\tif (beta==null) beta == 1;\n\tif (beta<=0) return NaN;\t\n    return -beta * Math.log(Math.random());\n}\n\n/**\n * Normal distribution implementation based on Box and Muller (1958) algorithm\n * Please note that in order to not to store state in this library we use only odd values\n * For discussion see A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 457\n * @param mean mean value\n * @param std standard deviation, std>=0\n * @returns Normally distributed random value\n */\nexport function Normal(mean, std) {\n    if (mean == null) mean = 0.0;\n    if (std == null) std = 1.0;\n    if (std < 0) return NaN;\n\n    let n = Math.sqrt(-2.0 * Math.log(Math.random())) * Math.cos(2.0 * Math.PI * Math.random());\n    return n * std + mean;\n}\n/**\n * Pareto distribution implementation based on \n * https://en.wikipedia.org/wiki/Pareto_distribution#Random_sample_generation\n * \n * @param alpha shape parameter, alpha > 0\n * @param minimum scale parameter, minimum > 0\n * @returns\n */\nexport function Pareto(alpha, minimum) {\n\tif (alpha == null) alpha = 1.0;\n\tif (minimum == null) minimum = 1.0;\n\tif (alpha <= 0 || minimum <= 0) return NaN;\n    return minimum / Math.pow(Math.random(), 1.0 / alpha);\n}\n\n\n/**\n * Log-logistic distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 460\n * @param alpha shape parameter, alpha > 0\n * @param beta scale parameter, beta > 0\n * @returns Log-logistic distributed random value\n */\nexport function Loglogistic(alpha, beta) {\n\tif (alpha == null) alpha = 1.0;\n\tif (beta == null) beta = 1.0;\n\tif (beta <= 0 || alpha <= 0) return NaN;\n\tvar u = Math.random();\n\treturn beta * Math.pow(u/(1-u), 1/alpha);\t\n}\n\n\n/**\n * Weibull distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 456\n * @param alpha shape parameter, alpha > 0\n * @param beta scale parameter, beta > 0\n * @returns Weibull distributed random value\n */\nexport function Weibull(alpha, beta) {\n\tif (alpha == null) alpha = 1.0;\n\tif (beta == null) beta = 1.0;\n\tif (beta <= 0 || alpha <= 0) return NaN;\t\n    return beta * Math.pow(-Math.log(1.0 - Math.random()), 1.0 / alpha);\n}\n\n\n/**\n * Erlang distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 453\n * @param k shape parameter, k = 1,2,3,...\n * @param beta scale parameter, beta > 0, beta = 1/lambda. For Erlang distribution beta is equal to the mean value.\n * @returns Erlang distributed random value\n */\nexport function Erlang(k, beta) {\n\tif (k == null) k = 1;\n\tif (beta == null) beta = 1.0;\n\tvar m = k | 0;\n\tif (beta <= 0 || m <= 0) return NaN;\n\tvar mult = 1.0;\n\tfor (var i=0;i<m;i++) {\n\t\tmult *= Math.random();\n\t}\n    return -beta/m*Math.log(mult);\n}\n\n\n/**\n * Triangular distribution implementation\n * @param a left side\n * @param b right side, b >= a\n * @param m triangle peak (mode), a <= m <= b\n * @returns Triangular distributed random value\n */\nexport function Triangular(a, b, m) {\n    if (a == null) a = 0.0;\n    if (b == null) b = 1.0;\n    if (m == null) m = 0.5;\n    if (a>b || m < a || m > b) return NaN;\n\tif (a==b) return a;\n    var c = (m - a) / (b - a);\n    var p = Math.random();\n    if (p <= c) {\n        return a + Math.sqrt(p * (b - a) * (m - a));\n    } else {\n        return b - Math.sqrt((1 - p) * (b - a) * (b - m));\n    }\n}\n\n\n/**\n * Trapezoidal distribution implementation\n * @param a left side\n * @param b right side, b >= a\n * @param c left trapezoid peak (mode)\n * @param d right trapezoid peak (mode), a <= c <= d <= b\n * @returns Trapezoidal distributed random value\n */\nexport function Trapezoidal(a, b, c, d) {\n    if (a == null) a = 0.0;\n    if (b == null) b = 1.0;\n    if (c == null) c = 0.25;\n    if (d == null) d = 0.75;\n    if (a > b || c < a || c > d || d > b) return NaN;\n\tif (a==b) return a;\n    var p1 = (c - a) / ( (b - a)+(d - c));\n    var p2 = (b - d) / ( (b - a)+(d - c));\n    var p = Math.random();\n    \n    if (p <= p1) {\n        return a + Math.sqrt(p * ((b - a)+(d - c)) * (c - a) );\n    } else if (p > 1-p2) {\n        return b - Math.sqrt((1 - p) * ((b - a)+(d - c)) * (b - d));\n    } else {\n    \treturn c + (d-c)*(p-p1)/(1.0 - p1 - p2);\n    }\n}\n\n/**\n * Lognormal distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 458\n * @param mean mean value\n * @param std standard deviation\n * @returns Lognormally distributed random value\n */\nexport function LogNormal(mean, std) {\n    if (mean == null) mean = 0.0;\n    if (std == null) std = 1.0;\n    if (std < 0) return NaN;\n    return Math.exp(Normal(mean, std))\n}\n\n\n\n/**\n * Bernoulli distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 464\n * @param p probability of 1\n * @returns Bernoulli distributed random value (zero or one)\n */\nexport function Bernoulli(p) {\n\tif (p==null) p = 0.5;\n\tif (p<0.0 | p > 1.0) return NaN;\n    if (Math.random()<=p)\n    \treturn 1;\n    else \n    \treturn 0;\n}\n\n\n/**\n * Binomial distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 469\n * @param n number of trials\n * @param p success probability in each trial\n * @returns Binomial distributed random value (0,1,...,n)\n */\nexport function Binomial(n,p) {\n\tif (n==null) n = 1;\n\tif (p==null) p = 0.5;\t\n\tvar t = n | 0;\n\tif ( p < 0.0 | p > 1.0 | t <= 0) return NaN;\n\tvar sum = 0;\n\tfor (var i=0;i<t;i++) {\n\t\tsum += Bernoulli(p);\n\t}\n    return sum;\n}\n\n/**\n * Geometric distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 469\n * @param p success probability \n * @returns Geometric distributed random value \n */\nexport function Geometric(p) {\n\tif (p==null) p = 0.5;\t\n\tif ( p <= 0.0 | p >= 1.0 ) return NaN;\t\n    return Math.floor(Math.log(Math.random())/Math.log(1-p) ) | 0;\n}\n\n/**\n * Poisson distribution implementation based on A.Law \"Simulation Modelling and Analysis\", 5e, Mc Graw-Hill, 2015, p. 470\n * @param lambda mean value \n * @returns Poisson distributed random value \n */\nexport function Poisson(lambda) {\n\tif (lambda==null) lambda = 1.0;\t\n\tif ( lambda <= 0.0 ) return NaN;\t\n\tvar a = Math.exp(-lambda);\n\tvar b = 1.0;\n\tvar i = 0;\t\n\twhile (true) {\n\t\tvar u = Math.random();\n\t\tb *= u;\n\t\tif (b < a) return i;\n\t\ti += 1;\n\t}\n}\n\n/**\n * Gamma distribution implementation.\n * This code has been copied from\n * https://github.com/btelles/simjs-updated/\n * simjs-updated is licensed under MIT Open Source License termns \n * @param alpha shape parameter\n * @param beta rate parameter \n * @returns Gamma distributed random value.\n */\nexport function Gamma(alpha, beta) {\n\tif (alpha == null) alpha = 1.0;\n\tif (beta == null) beta = 1.0;\n    if (alpha > 1.0) {\n        let ainv = Math.sqrt(2.0 * alpha - 1.0),\n            bbb = alpha - Math.log(4.0),\n            ccc = alpha + ainv;\n\n        while (true) {  // eslint-disable-line no-constant-condition\n            let u1 = random();\n\n            if ((u1 < 1e-7) || (u > 0.9999999)) {\n                continue;\n            }\n            let u2 = 1.0 - random(),\n                v = Math.log(u1 / (1.0 - u1)) / ainv,\n                x = alpha * Math.exp(v),\n                z = u1 * u1 * u2,\n                r = bbb + ccc * v - x;\n            if ((r + Math.log(4.5) - 3.5 * z >= 0.0) || (r >= Math.log(z))) {\n                return x * beta;\n            }\n        }\n    } else if (alpha == 1.0) {\n        let u = random();\n        while (u <= 1e-7) {\n            u = random();\n        }\n        return -Math.log(u) * beta;\n    } else {\n        let x;\n        while (true) {\n            let u = random(),\n                b = (Math.E + alpha) / Math.E,\n                p = b * u;\n            if (p <= 1.0) {\n                x = Math.pow(p, 1.0 / alpha);\n            } else {\n                x = -Math.log((b - p) / alpha);\n            }\n            const u1 = random();\n\n            if (p > 1.0) {\n                if (u1 <= Math.pow(x, (alpha - 1.0))) {\n                    break;\n                }\n            } else if (u1 <= Math.exp(-x)) {\n                break;\n            }\n        }\n        return x * beta;\n    }\n}\n","export * from './src/sd-random';\n"]}